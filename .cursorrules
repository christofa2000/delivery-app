React Native Delivery App (Optimizado)

Eres un experto en TypeScript, React Native, Expo, React Query, Zustand, expo-router, Mobile UI/UX y arquitectura limpia.
Tu objetivo es generar cÃ³digo profesional, escalable y con buenas prÃ¡cticas, igual que una app real tipo Rappi / PedidosYa / Uber Eats.

ğŸ“ Estructura general del proyecto

1. Estructura por features

Organizar el cÃ³digo por features, no por tipo de archivo.

Cada componente o pantalla debe tener su propio folder:

feature/
index.tsx
styles.ts
types.ts
hooks.ts (si aplica)

2. Directorios principales
   components/ â†’ Componentes reutilizables (botones, cards, modales, inputs)
   app/ â†’ Screens y navegaciÃ³n (expo-router file-based routing)
   services/ â†’ APIs, axios-client, constants, types globales
   assets/ â†’ Ãconos, imÃ¡genes, fuentes

ğŸ“± Pantallas (app/)

Cada pantalla debe tener:
index.tsx (lÃ³gica) + styles.ts (estilos) + types.ts (si aplica)

El nombre del componente principal debe ser PascalCase:
Home, Search, RestaurantDetails, Checkout, etc.

Reglas

Usar expo-router SIEMPRE (tabs, stacks, layouts).

Usar KeyboardAvoidingView + ScrollView para pantallas con inputs.

Antes de crear componentes nuevos, revisar components/ para reutilizar.

ğŸ§© Componentes (components/)

Cada componente reutilizable debe seguir este formato:

components/button/
index.tsx
styles.ts
types.ts

Reglas

Exportar SIEMPRE como default:

const MyButton: FC<MyButtonProps> = ({ ... }) => { ... }
export default MyButton;

Nunca poner estilos inline.

Componentes 100% tipados.

Props siempre bien definidos en types.ts.

ğŸŒ APIs (services/apis)
Estructura
services/
apis/
axios-client.ts
index.ts
constants/
index.ts
types/
api-types.ts
form-types.ts

Reglas de API

Usar axiosClient con interceptores para tokens, errores y logs.

Cada mÃ©todo debe estar definido dentro del objeto apis:

export const apis = {
authenticate: ({ idToken }: ApiTypes.Authenticate) =>
axiosClient.post<ApiTypes.AuthResponse>("auth/authenticate", { idToken }),
};

Uso:

const { data } = await apis.authenticate({ idToken });

ğŸ“¡ Data Fetching & Estado
React Query â€“ obligatorio para data remota

Usar hooks como:

useRestaurants()

useRestaurant(id)

useOrders()

Manejar:

caching

retry

refetch

loading + error states

Zustand â€“ obligatorio para estado global

Ideal para:

Carrito ğŸ›’

Usuario / sesiÃ³n ğŸ”

Filtros

Estado UI persistido

El carrito debe persistirse en AsyncStorage.

ğŸ§ª Formularios
Formik + Yup obligatorio para:

Login

Registro

Datos del usuario

DirecciÃ³n de entrega

Checkout

MÃ©todos de pago

Opcional para inputs simples (ej.: search bar).

ğŸ§­ NavegaciÃ³n

Usar expo-router SIEMPRE.

No usar React Navigation manual salvo que Cursor lo justifique.

Usar layouts:

(tabs)/home

(auth)/login

restaurant/[id]

Deep linking debe seguir el formato de expo-router.

ğŸ¨ Estilos

Cero estilos inline.

Siempre usar StyleSheet.create() en styles.ts.

Los estilos deben ser simples, consistentes y mÃ³viles.

Soporte para dark mode SIEMPRE (aunque sea bÃ¡sico).

ğŸ”¤ Convenciones

camelCase â†’ variables, funciones, hooks

PascalCase â†’ componentes, screens

kebab-case â†’ carpetas (restaurant-details, user-profile)

Nunca usar nombres ambiguos

Nunca usar any

âš™ï¸ ConfiguraciÃ³n / Seguridad

Nunca hardcodear URLs o keys â†’ usar .env o app.config.js.

Logs controlados (sin console.log en producciÃ³n).

Manejar errores de API en un solo lugar (interceptors).

ğŸ§ª Testing

Usar Jest + React Native Testing Library.

Testear:

componentes crÃ­ticos

lÃ³gica del carrito

flujo de login

Si aparece un flujo crÃ­tico (checkout, pago), sugiere test E2E.

ğŸ” Reglas especÃ­ficas para app tipo Rappi
Carrito

Debe estar en Zustand.

Persistencia con AsyncStorage.

MÃ©todos obligatorios:

addItem

removeItem

updateQuantity

clearCart

getTotal

Restaurantes

Listas grandes â†’ FlatList optimizada (keyExtractor, getItemLayout).

Skeleton loaders para mejorar percepciÃ³n de performance.

UbicaciÃ³n / Direcciones

Encapsular permisos en hooks:

useLocation()

useUserAddress()

Pedidos

Estados: pending â€¢ accepted â€¢ preparing â€¢ delivering â€¢ completed.

Simular actualizaciones con intervalos en caso de demo.

ğŸ§  FilosofÃ­a general

CÃ³digo limpio, simple, y sin magia extraÃ±a.

Reutilizar componentes antes de crear nuevos.

Arquitectura sÃ³lida aunque sea demo.

Todo debe poder escalar a una app real sin cambios drÃ¡sticos.

ğŸŸ© Cuando no entiendas algo

Siempre pedir aclaraciÃ³n antes de inventar o asumir.
